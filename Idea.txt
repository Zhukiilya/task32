1) Есть два человека - отправитель и получатель. Отправитель хочет отправить свое 
сообщение получателю, при этом он хочет, чтобы никто не узнал о содержании сообщеyия,
кроме отправителя, чтобы никто не мог видоизменить его "письмо".
2) Формирование общего ключа для симметричного шифрования в соответствии со стандартом RFC8731.
Для формирования общего ключа рекомендуется исползовать ECDH (Elliptic Curve Diffy Hellman) c аутентификацией. 
В соответствии со стандартом RFC8731 используется Curve25519
    1. Отправитель и получатель выбирают себе приватные ключи d_a и d_b соответсвенно с помощью
       криптографически стойкого генератора псевдослучайных чисел/генератора истинно случайных чисел 
    2.1 Отправитель формирует свой публичный ключ скалярно умножая d_a на G, где G - базовая точка на эллиптической 
        кривой. Из полученных координат берется x и "маскируется" таким образом, чтобы x входил в диапозон
        [2^254 + 8, 2^255 - 1]. Маскированный x - и есть публичный ключ отправителя. Будем называть публичным ключом
        отправителя P_ax.
    2.2 Аналогичным образом получает свой публичный ключ получатель сообщения (в скалярном умножении вместо 
        d_a используется d_b). Будем называть публичным ключом получателя P_bx.
    Примечания:
    Размер d = размер публичного ключа = 32 байта. 
    Скалярное умножение d на G - cложение точек на эллиптической кривой d раз
    3. Обмен публичными ключами
    4.1 После обмена публичными ключами отправитель восстанавливает всю точку на эллиптической кривой (d_b*G)
        с помощью публичного ключа получателя, который является x координатой этой самой точки (P_bx от P_b).
        Найденная точка P_b умножается скалярно на d_a (приватный ключ отправителя). От полученной точки S берется 
        x координата. 
    4.2 После обмена публичными ключами получатель восстанавливает всю точку на эллиптической кривой (d_a*G)
        с помощью публичного ключа отправителя, который является x координатой этой самой точки (P_ax от P_a).
        Найденная точка P_a умножается скалярно на d_b (приватный ключ получателя). От полученной точки S берется 
        x координата.
    Этап 4 формульно: 
        S_a = P_b*d_a = (d_b*G)*d_a = (d_b*d_a)*G (скалярное умножение (d_b*d_a) на G)
        S_b = P_a*d_b = (d_a*G)*d_b = (d_b*d_a)*G (скалярное умножение (d_b*d_a) на G)
    Вывод по этапам 1-4: 
        1. Злоумышленник, зная только G и публичные ключи, не может вычислить приватные ключи, т.к 
        задача, которую ему надо решить, называется ECDLP (Elliptic Curve Discrete Logarithm Problem). Для ее решения 
        с помощью новейших квантовых компьютеров злоумышленнику понадобятся миллиарды лет.
        2. Злоумышленник, зная только d_a*G и d_b*G для того, чтобы узнать S = (d_b*d_a)*G должен также решить 
        Elliptic Curve Discrete Logarithm Problem, что займет у него миллиарды лет. 
        Сложность Elliptic Curve Discrete Logarithm Problem подтверждена NIST SP 800-186.
        3. Т.к S_a = S_b = (d_b*d_a)*G отправитель и получатель получили неизвестный злоумышленнику общий секрет.
    5. В соответсвии со стандартом NIST SP 800-56A Rev.3 для получения ключа для симметричного шифрования используют 
       KDF (Key Deviration Function). Если нам нужен 256-битный ключ, целесообразно использовать HKDF-SHA256 как 
       KDF, одобренный 
3) Получив общий ключ (необходимые инициализирующие значения для ГПСЧ) отправитель теперь может зашифровать свое сообщение сложив методом XOR открытый текст с гаммой, которую генериует ГПСЧ; получатель сможет расшифровать сообщение сложив методом XOR гамму с шифрованным текстом. Гаммы, генерируемы ГПСЧ на стороне отправителя и 
получателя будут одинаковые за счет одинаковых инициализирующих значений, сгенерированных раннее алгориитмом ECDH.
